<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <meta name="description" content="Zig Chinese Community is dedicated to sharing and spreading the use of Zig language among Chinese users.">
    <title>Zig 语言中文社区</title>
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- TODO replace this -->
    
  <link type="text/css" rel="stylesheet" href="/style.css">

  </head>
  <body id="body">
    <div class="header">
      <a href="/" class="site-title"><h1>Zig 语言中文社区</h1></a>
      <nav>
        <a href="/learn/">学习 Zig</a>
         &nbsp; • &nbsp;
        <a href="/monthly/">月刊</a>
         &nbsp; • &nbsp;
        <a href="/post/">博客</a>
         &nbsp; • &nbsp;
        <a href="/contributing/">贡献</a>
         &nbsp; • &nbsp;
        <a href="/community/">社区</a>
      </nav>
    </div>
    
  <!-- TODO: 根据页面内容长度决定是否显示 TOC -->
  <div class="docs"></div>
  <div class="content"><blockquote><p>原文地址：<a href="https://www.openmymind.net/learning_zig/generics" target="_blank">https://www.openmymind.net/learning_zig/generics</a></p></blockquote><p>在上一小节中，我们创建了一个名为 <code>IntList</code> 的动态数组。该数据结构的目标是保存数目不定的数值。虽然我们使用的算法适用于任何类型的数据，但我们的实现与 i64 值绑定。这就需要使用泛型，其目的是从特定类型中抽象出算法和数据结构。</p><p>许多语言使用特殊的语法和特定的泛型规则来实现泛型。而在 Zig 中，泛型并不是一种特定的功能，而更多地体现了语言的能力。具体来说，泛型利用了 Zig 强大的编译时元编程功能。</p><p>我们先来看一个简单的例子，以了解我们的想法：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin function_call variable type">IntArray</span><span class="punctuation_bracket">(</span><span class="number">3</span><span class="punctuation_bracket">)</span> <span class="operator">=</span> <span class="constant_builtin">undefined</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_bracket">[</span><span class="number">1</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_bracket">[</span><span class="number">2</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">arr</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">IntArray</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">length</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="type_builtin">type</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">length</span><span class="punctuation_bracket">]</span><span class="type_builtin">i64</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>上述代码会打印了 <code>{ 1, 10, 100 }</code>。有趣的是，我们有一个返回类型的函数（因此函数是 PascalCase）。这也不是普通的类型，而是由函数参数动态确定的类型。这段代码之所以能运行，是因为我们将 <code>length</code> 声明为 <code>comptime</code>。也就是说，我们要求任何调用 <code>IntArray</code> 的人传递一个编译时已知的长度参数。这是必要的，因为我们的函数返回一个类型，而类型必须始终是编译时已知的。</p><p>函数可以返回任何类型，而不仅仅是基本类型和数组。例如，只需稍作改动，我们就可以让函数返回一个结构体：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin function_call variable type">IntArray</span><span class="punctuation_bracket">(</span><span class="number">3</span><span class="punctuation_bracket">)</span> <span class="operator">=</span> <span class="constant_builtin">undefined</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">1</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">2</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">IntArray</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">length</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="type_builtin">type</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">length</span><span class="punctuation_bracket">]</span><span class="type_builtin">i64</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>也许看起来很奇怪，但 <code>arr</code> 的类型确实是 <code>IntArray(3)</code>。它和其他类型一样，是一个类型，而 <code>arr</code> 和其他值一样，是一个值。如果我们调用 <code>IntArray(7)</code>，那就是另一种类型了。也许我们可以让事情变得更简洁：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">arr</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">IntArray</span><span class="punctuation_bracket">(</span><span class="number">3</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">init</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">1</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">2</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">arr</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">IntArray</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">length</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="type_builtin">type</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">length</span><span class="punctuation_bracket">]</span><span class="type_builtin">i64</span><span class="punctuation_delimiter">,</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">init</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="constant variable_builtin function_call variable type">IntArray</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">length</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="keyword_return">return</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span> <span class="operator">=</span> <span class="constant_builtin">undefined</span><span class="punctuation_delimiter">,</span>
			<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>乍一看，这可能并不整齐。但除了匿名和嵌套在一个函数中之外，我们的结构看起来就像我们目前看到的其他结构一样。它有字段，有函数。你知道人们常说『如果它看起来像一只鸭子，那么就就是一只鸭子』。那么，这个结构看起来、游起来和叫起来都像一个正常的结构，因为它本身就是一个结构体。</p><p>希望上面这个示例能让你熟悉返回类型的函数和相应的语法。为了得到一个更典型的范型，我们需要做最后一个改动：我们的函数必须接受一个类型。实际上，这只是一个很小的改动，但 <code>type</code> 会比 <code>usize</code> 更抽象，所以我们慢慢来。让我们进行一次飞跃，修改之前的 <code>IntList</code>，使其能与任何类型一起工作。我们先从基本结构开始：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">List</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">T</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">type</span><span class="punctuation_bracket">)</span> <span class="type_builtin">type</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable_member variable">pos</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Allocator</span><span class="punctuation_delimiter">,</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Allocator</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="constant variable_builtin type variable">List</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="keyword_return">return</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">pos</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">,</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">,</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">alloc</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span> <span class="number">4</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
			<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>上面的结构与 <code>IntList</code> 几乎完全相同，只是 <code>i64</code> 被替换成了 <code>T</code>。我们本可以叫它 <code>item_type</code>。不过，按照 Zig 的命名约定，<code>type</code> 类型的变量使用 <code>PascalCase</code> 风格。</p><blockquote><p>无论好坏，使用单个字母表示类型参数的历史都比 Zig 要悠久得多。在大多数语言中，T 是常用的默认值，但你也会看到根据具体语境而变化的情况，例如哈希映射使用 K 和 V 来表示键和值参数类型。</p></blockquote><p>如果你对上述代码还有疑问，可以着重看使用 T 的两个地方：<code>items：[]T</code> 和 <code>allocator.alloc(T, 4)</code>。当我们要使用这个通用类型时，我们将使用</p><pre><code class="zig"><span class="keyword">var</span> <span class="constant variable_builtin type variable">list</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">List</span><span class="punctuation_bracket">(</span><span class="type_builtin">u32</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">allocator</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>编译代码时，编译器会通过查找每个 <code>T</code> 并将其替换为 <code>u32</code> 来创建一个新类型。如果我们再次使用 <code>List(u32)</code>，编译器将重新使用之前创建的类型。如果我们为 <code>T</code> 指定一个新值，例如 <code>List(bool)</code> 或 <code>List(User)</code>，就会创建与之对应的新类型。</p><p>为了完成通用的 List，我们可以复制并粘贴 <code>IntList</code> 代码的其余部分，然后用 <code>T</code> 替换 <code>i64</code>：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="keyword">const</span> <span class="constant variable_builtin type variable">Allocator</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Allocator</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">gpa</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">heap</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">GeneralPurposeAllocator</span><span class="punctuation_bracket">(</span><span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">{</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">allocator</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">gpa</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">allocator</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

	<span class="keyword">var</span> <span class="constant variable_builtin type variable">list</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">List</span><span class="punctuation_bracket">(</span><span class="type_builtin">u32</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">allocator</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="keyword">defer</span> <span class="constant variable_builtin type variable">list</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">deinit</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

	<span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="number">0</span><span class="operator">..</span><span class="number">10</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">list</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="function_builtin">@intCast</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>

	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">list</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="operator">..</span><span class="constant variable_builtin type variable">list</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">pos</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">List</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">T</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">type</span><span class="punctuation_bracket">)</span> <span class="type_builtin">type</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable_member variable">pos</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Allocator</span><span class="punctuation_delimiter">,</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Allocator</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="constant variable_builtin type variable">List</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="keyword_return">return</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">pos</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">,</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">,</span>
				<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">alloc</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span> <span class="number">4</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
			<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">deinit</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin function_call variable type">List</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
			<span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">free</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">List</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">value</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
			<span class="keyword">const</span> <span class="constant variable_builtin type variable">pos</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">pos</span><span class="punctuation_delimiter">;</span>
			<span class="keyword">const</span> <span class="constant variable_builtin type variable">len</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">len</span><span class="punctuation_delimiter">;</span>

			<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">pos</span> <span class="operator">==</span> <span class="constant variable_builtin type variable">len</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
				<span class="comment_documentation comment spell">// we&apos;ve run out of space</span>
				<span class="comment_documentation comment spell">// create a new slice that&apos;s twice as large</span>
				<span class="keyword">var</span> <span class="constant variable_builtin type variable">larger</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">alloc</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">len</span> <span class="operator">*</span> <span class="number">2</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

				<span class="comment_documentation comment spell">// copy the items we previously added to our new space</span>
				<span class="function_builtin">@memcpy</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">larger</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="operator">..</span><span class="constant variable_builtin type variable">len</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

				<span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">free</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

				<span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">larger</span><span class="punctuation_delimiter">;</span>
			<span class="punctuation_bracket">}</span>

			<span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">pos</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">value</span><span class="punctuation_delimiter">;</span>
			<span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">pos</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">pos</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>我们的 <code>init</code> 函数返回一个 <code>List(T)</code>，我们的 <code>deinit</code> 和 <code>add</code> 函数使用 <code>List(T)</code> 和 <code>*List(T)</code> 作为参数。在我们的这个简单的示例中，这样做没有问题，但对于大型数据结构，编写完整的通用名称可能会变得有点繁琐，尤其是当我们有多个类型参数时（例如，散列映射的键和值需要使用不同的类型）。<code>@This()</code> 内置函数会返回它被调用时的最内层类型。一般来说，我们会这样定义 <code>List(T)</code>：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">List</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">T</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">type</span><span class="punctuation_bracket">)</span> <span class="type_builtin">type</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable_member variable">pos</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">items</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Allocator</span><span class="punctuation_delimiter">,</span>

		<span class="comment_documentation comment spell">// Added</span>
		<span class="keyword">const</span> <span class="module constant variable_builtin type variable">Self</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@This</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Allocator</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="constant variable_builtin type variable">Self</span> <span class="punctuation_bracket">{</span>
			<span class="comment_documentation comment spell">// ... same code</span>
		<span class="punctuation_bracket">}</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">deinit</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Self</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
			<span class="comment_documentation comment spell">// .. same code</span>
		<span class="punctuation_bracket">}</span>

		<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">Self</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">value</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
			<span class="comment_documentation comment spell">// .. same code</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p><code>Self</code> 并不是一个特殊的名称，它只是一个变量，而且是 <code>PascalCase</code> 风格，因为它的值是一种类型。我们可以在之前使用 <code>List(T)</code> 的地方用 <code>Self</code> 来替代。</p><hr><p>我们可以创建更复杂的示例，使用多种类型参数和更先进的算法。但归根结底，泛型代码的关键点与上述简单示例相差无几。在下一部分，我们将在研究标准库中的 <code>ArrayList(T)</code> 和 <code>StringHashMap(V)</code> 时再次讨论泛型。</p></div>

    <footer>
      <div>
        <div>
          <p>&copy; 2022–2025 |
            <a href="https://github.com/zigcc/zigcc.github.io">Source Code</a>
            |
            <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">BY-NC-ND 4.0</a>
            |
            <!--TODO <a href="/index.xml">RSS</a> --></p>
        </div>
        <div>
          <a href="https://github.com/orgs/zigcc/discussions">
            <i class="fab fa-github"></i>
          </a>
          <a href="https://discord.gg/UraRxD6WXD">
            <i class="fab fa-discord"></i>
          </a>
          <a href="https://t.me/ZigChinese">
            <i class="fab fa-telegram"></i>
          </a>
          <a href="mailto:hello@ziglang.cc">
            <i class="fa fa-envelope"></i>
          </a>
        </div>
      </div>
    </footer>
  </body>
</html>