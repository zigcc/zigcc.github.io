<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <meta name="description" content="Zig Chinese Community is dedicated to sharing and spreading the use of Zig language among Chinese users.">
    <title>Zig 语言中文社区</title>
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- TODO replace this -->
    
  <link type="text/css" rel="stylesheet" href="/style.css">

  </head>
  <body id="body">
    <div class="header">
      <a href="/" class="site-title"><h1>Zig 语言中文社区</h1></a>
      <nav>
        <a href="/learn/">学习 Zig</a>
         &nbsp; • &nbsp;
        <a href="/monthly/">月刊</a>
         &nbsp; • &nbsp;
        <a href="/post/">博客</a>
         &nbsp; • &nbsp;
        <a href="/contributing/">贡献</a>
         &nbsp; • &nbsp;
        <a href="/community/">社区</a>
      </nav>
    </div>
    
  <!-- TODO: 根据页面内容长度决定是否显示 TOC -->
  <div class="docs">
    <!-- TODO: 层级 h1 -->
    <h1>Table of Contents</h1>
    <div><ul>
<li>控制流</li><li>枚举</li><li>带标签的联合 Tagged Union</li><li>可选类型 Optional</li><li>未定义的值 Undefined</li><li>错误 Errors</ul></div>
  </div>
  <div class="content"><blockquote><p>原文地址：<a href="https://www.openmymind.net/learning_zig/language_overview_2" target="_blank">https://www.openmymind.net/learning_zig/language_overview_2</a></p></blockquote><p>本部分继续上一部分的内容：熟悉 Zig 语言。我们将探索 Zig 的控制流和结构以外的类型。通过这两部分的学习，我们将掌握 Zig 语言的大部分语法，这让我们可以继续深入 Zig 语言，同时也为如何使用 std 标准库打下了基础。</p><h1>控制流</h1><p>Zig 的控制流很可能是我们所熟悉的，但它与 Zig 语言的其他特性协同工作是我们还没有探索过。我们先简单概述控制流的基本使用，之后在讨论依赖控制流的相关特性时，再来重新回顾。</p><p>你会注意到，我们使用 <code>and</code> 和 <code>or</code> 来代替逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code>。与大多数语言一样，<code>and</code> 和 <code>or</code> 会短路执行，即如果左侧为假，<code>and</code> 的右侧运算符就不会执行；如果左侧为真，<code>or</code> 的右侧就不会执行。在 Zig 中，控制流是通过关键字完成的，因此要使用 <code>and</code> 和 <code>or</code>。</p><p>此外，比较运算符 <code>==</code> 在切片（如 <code>[]const u8</code>，即字符串）间不起作用。在大多数情况下，需要使用 <code>std.mem.eql(u8,str1,str2)</code>，它将比较两个片段的长度和字节数。</p><p>Zig 中，<code>if</code>、<code>else if</code> 和 <code>else</code> 也很常见：</p><pre><code class="zig"><span class="comment_documentation comment spell">// std.mem.eql 将逐字节进行比较，对于字符串来说它是大小写敏感的。</span>
<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">eql</span><span class="punctuation_bracket">(</span><span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">method</span><span class="punctuation_delimiter">,</span> <span class="string">&quot;GET&quot;</span><span class="punctuation_bracket">)</span> <span class="keyword_operator">or</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">eql</span><span class="punctuation_bracket">(</span><span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">method</span><span class="punctuation_delimiter">,</span> <span class="string">&quot;HEAD&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// 处理 GET 请求</span>
<span class="punctuation_bracket">}</span> <span class="keyword_conditional">else</span> <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">eql</span><span class="punctuation_bracket">(</span><span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">method</span><span class="punctuation_delimiter">,</span> <span class="string">&quot;POST&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// 处理 POST 请求</span>
<span class="punctuation_bracket">}</span> <span class="keyword_conditional">else</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// ...</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<blockquote><p><code>std.mem.eql</code> 的第一个参数是一个类型，这里是 <code>u8</code>。这是我们看到的第一个泛型函数。我们将在后面的部分进一步探讨。</p></blockquote><p>上述示例比较的是 ASCII 字符串，不区分大小写可能更合适，这时 <code>std.ascii.eqlIgnoreCase(str1, str2)</code> 可能是更好的选择。</p><p>虽然没有三元运算符，但可以使用 if/else 来代替：</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">super</span> <span class="operator">=</span> <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">power</span> <span class="operator">&gt;</span> <span class="number">9000</span><span class="punctuation_bracket">)</span> <span class="constant variable_builtin type variable">true</span> <span class="keyword_conditional">else</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p><code>switch</code> 语句类似于<code>if/else if/else</code>，但具有穷举的优点。也就是说，如果没有涵盖所有情况，编译时就会出错。下面这段代码将无法编译：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">anniversaryName</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">years_married</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u16</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u8</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_conditional">switch</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">years_married</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
		<span class="number">1</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;paper&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">2</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;cotton&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">3</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;leather&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">4</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;flower&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">5</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;wood&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">6</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;sugar&quot;</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>编译时会报错：<code>switch</code> 必须处理所有的可能性。由于我们的 <code>years_married</code> 是一个 16 位整数，这是否意味着我们需要处理所有 64K 中情况？是的，不过我们可以使用 <code>else</code> 来代替：</p><pre><code class="zig"><span class="comment_documentation comment spell">// ...</span>
<span class="number">6</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;sugar&quot;</span><span class="punctuation_delimiter">,</span>
<span class="constant variable_builtin type variable">else</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;no more gifts for you&quot;</span><span class="punctuation_delimiter">,</span>
</code></pre>
<p>在进行匹配时，我们可以合并多个 <code>case</code> 或使用范围；在进行处理时，可以使用代码块来处理复杂的情况：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">arrivalTimeDesc</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">minutes</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u16</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">is_late</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">bool</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u8</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_conditional">switch</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">minutes</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
		<span class="number">0</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;arrived&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">1</span><span class="punctuation_delimiter">,</span> <span class="number">2</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;soon&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="number">3</span><span class="variable_builtin">...</span><span class="number">5</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span> <span class="string">&quot;no more than 5 minutes&quot;</span><span class="punctuation_delimiter">,</span>
		<span class="keyword_conditional">else</span> <span class="punctuation_delimiter">=&gt;</span> <span class="punctuation_bracket">{</span>
			<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="operator">!</span><span class="constant variable_builtin type variable">is_late</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
				<span class="keyword_return">return</span> <span class="string">&quot;sorry, it&apos;ll be a while&quot;</span><span class="punctuation_delimiter">;</span>
			<span class="punctuation_bracket">}</span>
			<span class="comment_documentation comment spell">// todo, something is very wrong</span>
			<span class="keyword_return">return</span> <span class="string">&quot;never&quot;</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>虽然 <code>switch</code> 在很多情况下都很有用，但在处理枚举时，它穷举的性质才真正发挥了作用，我们很快就会谈到枚举。</p><p>Zig 的 <code>for</code> 循环用于遍历数组、切片和范围。例如，我们可以这样写：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">contains</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">haystack</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">needle</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u32</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">haystack</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">value</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">needle</span> <span class="operator">==</span> <span class="constant variable_builtin type variable">value</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">true</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span>
	<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p><code>for</code> 循环也可以同时处理多个序列，只要这些序列的长度相同。上面我们使用了 <code>std.mem.eql</code> 函数，下面是其大致实现：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">eql</span><span class="punctuation_bracket">(</span><span class="keyword_modifier">comptime</span> <span class="constant variable_builtin variable_parameter variable type">T</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">type</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">a</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">T</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">b</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">T</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// if they aren&apos;t the same length, they can&apos;t be equal</span>
	<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">a</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">len</span> <span class="operator">!=</span> <span class="constant variable_builtin type variable">b</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">len</span><span class="punctuation_bracket">)</span> <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>

	<span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">a</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">b</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">a_elem</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">b_elem</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">a_elem</span> <span class="operator">!=</span> <span class="constant variable_builtin type variable">b_elem</span><span class="punctuation_bracket">)</span> <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>

	<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">true</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>一开始的 <code>if</code> 检查不仅是一个很好的性能优化，还是一个必要的防护措施。如果我们去掉它，并传递不同长度的参数，就会出现运行时 <code>panic</code>。<code>for</code> 在作用于多个序列上时，要求其长度相等。</p><p><code>for</code> 循环也可以遍历范围，例如：</p><pre><code class="zig"><span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="number">0</span><span class="operator">..</span><span class="number">10</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<blockquote><p>在 <code>switch</code> 中，范围使用了三个点，即 <code>3...6</code>，而这个示例中，范围使用了两个点，即 <code>0..10</code>。这是因为在 switch 中，范围的两端都是闭区间，而 for 则是左闭右开。</p></blockquote><p>与一个（或多个）序列组合使用时，它的作用就真正体现出来了：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">indexOf</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">haystack</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">needle</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u32</span><span class="punctuation_bracket">)</span> <span class="operator">?</span><span class="type_builtin">usize</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">haystack</span><span class="punctuation_delimiter">,</span> <span class="number">0</span><span class="operator">..</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">value</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">needle</span> <span class="operator">==</span> <span class="constant variable_builtin type variable">value</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">i</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span>
	<span class="keyword_return">return</span> <span class="constant_builtin">null</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<blockquote><p>这是对可空类型的初步了解。</p></blockquote><p>范围的末端由 <code>haystack</code> 的长度推断，不过我们也可以写出 <code>0..haystack.len</code>，但这没有必要。<code>for</code> 循环不支持常见的 <code>init; compare; step</code> 风格，对于这种情况，可以使用 <code>while</code>。</p><p>因为 <code>while</code> 比较简单，形式如下：<code>while (condition) { }</code>，这有利于更好地控制迭代。例如，在计算字符串中转义序列的数量时，我们需要将迭代器递增 2 以避免重复计算 <code>\\</code>：</p><pre><code class="zig"><span class="keyword">var</span> <span class="constant variable_builtin type variable">escape_count</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">i</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>
	<span class="comment_documentation comment spell">// 反斜杠用作转义字符，因此我们需要用一个反斜杠来转义它。</span>
	<span class="keyword_repeat">while</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span> <span class="operator">&lt;</span> <span class="constant variable_builtin type variable">src</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">len</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">src</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket">]</span> <span class="operator">==</span> <span class="character">&apos;</span><span class="character string_escape">\\</span><span class="character">&apos;</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="constant variable_builtin type variable">i</span> <span class="operator">+=</span> <span class="number">2</span><span class="punctuation_delimiter">;</span>
			<span class="constant variable_builtin type variable">escape_count</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span> <span class="keyword_conditional">else</span> <span class="punctuation_bracket">{</span>
			<span class="constant variable_builtin type variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>我们在临时变量 <code>i</code> 和 <code>while</code> 循环周围添加了一个显式的代码块。这缩小了 <code>i</code> 的作用范围。这样的代码块可能会很有用，尽管在这个例子中可能有些过度。不过，上述例子已经是 Zig 中最接近传统的 <code>for(init; compare; step)</code> 循环的写法了。</p><p><code>while</code> 可以包含 <code>else</code> 子句，当条件为假时执行 <code>else</code> 子句。它还可以接受在每次迭代后要执行的语句。多个语句可以用 ; 分隔。在 <code>for</code> 支持遍历多个序列之前，这一功能很常用。上述语句可写成</p><pre><code class="zig"><span class="keyword">var</span> <span class="constant variable_builtin type variable">i</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>
<span class="keyword">var</span> <span class="constant variable_builtin type variable">escape_count</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>

<span class="comment_documentation comment spell">// 改写后的</span>
<span class="keyword_repeat">while</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span> <span class="operator">&lt;</span> <span class="constant variable_builtin type variable">src</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">len</span><span class="punctuation_bracket">)</span> <span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">src</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket">]</span> <span class="operator">==</span> <span class="character">&apos;</span><span class="character string_escape">\\</span><span class="character">&apos;</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
		<span class="comment_documentation comment spell">// +1 here, and +1 above == +2</span>
		<span class="comment_documentation comment spell">// 这里 +1，上面也 +1，相当于 +2</span>
		<span class="constant variable_builtin type variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
		<span class="constant variable_builtin type variable">escape_count</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>

</code></pre>
<p>Zig 也支持 <code>break</code> 和 <code>continue</code> 关键字，用于跳出最内层循环或跳转到下一次迭代。</p><p>代码块可以附带标签（label），<code>break</code> 和 <code>continue</code> 可以作用在特定标签上。举例说明：</p><pre><code class="zig"><span class="constant variable_builtin type variable_member variable">outer</span><span class="punctuation_delimiter">:</span> <span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="number">1</span><span class="operator">..</span><span class="number">10</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span><span class="operator">..</span><span class="number">10</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">j</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span> <span class="operator">*</span> <span class="constant variable_builtin type variable">j</span> <span class="operator">&gt;</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">i</span><span class="operator">+</span><span class="constant variable_builtin type variable">i</span> <span class="operator">+</span> <span class="constant variable_builtin type variable">j</span><span class="operator">+</span><span class="constant variable_builtin type variable">j</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="keyword_repeat">continue</span> <span class="punctuation_delimiter">:</span><span class="constant label type variable variable_builtin">outer</span><span class="punctuation_delimiter">;</span>
		<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{d} + {d} &gt;= {d} * {d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">i</span><span class="operator">+</span><span class="constant variable_builtin type variable">i</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">j</span><span class="operator">+</span><span class="constant variable_builtin type variable">j</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">i</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">j</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p><code>break</code> 还有另一个有趣的行为，即从代码块中返回值：</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">personality_analysis</span> <span class="operator">=</span> <span class="constant label type variable variable_builtin">blk</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">tea_vote</span> <span class="operator">&gt;</span> <span class="constant variable_builtin type variable">coffee_vote</span><span class="punctuation_bracket">)</span> <span class="keyword_repeat">break</span> <span class="punctuation_delimiter">:</span><span class="constant label type variable variable_builtin">blk</span> <span class="string">&quot;sane&quot;</span><span class="punctuation_delimiter">;</span>
	<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">tea_vote</span> <span class="operator">==</span> <span class="constant variable_builtin type variable">coffee_vote</span><span class="punctuation_bracket">)</span> <span class="keyword_repeat">break</span> <span class="punctuation_delimiter">:</span><span class="constant label type variable variable_builtin">blk</span> <span class="string">&quot;whatever&quot;</span><span class="punctuation_delimiter">;</span>
	<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">tea_vote</span> <span class="operator">&lt;</span> <span class="constant variable_builtin type variable">coffee_vote</span><span class="punctuation_bracket">)</span> <span class="keyword_repeat">break</span> <span class="punctuation_delimiter">:</span><span class="constant label type variable variable_builtin">blk</span> <span class="string">&quot;dangerous&quot;</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>像这样有返回值的的块，必须以分号结束。</p><p>稍后，当我们讨论带标签的联合（tagged union）、错误联合（error unions）和可选类型（Optional）时，我们将看到控制流如何与它们联合使用。</p><h1>枚举</h1><p>枚举是带有标签的整数常量。它们的定义很像结构体：</p><pre><code class="zig"><span class="comment_documentation comment spell">// 可以是 &quot;pub&quot; 的</span>
<span class="keyword">const</span> <span class="constant variable_builtin type variable">Status</span> <span class="operator">=</span> <span class="keyword_type">enum</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">ok</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">bad</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">unknown</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>与结构体一样，枚举可以包含其他定义，包括函数，这些函数可以选择性地将枚举作为第一个参数：</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">Stage</span> <span class="operator">=</span> <span class="keyword_type">enum</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">validate</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">awaiting_confirmation</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">confirmed</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">err</span><span class="punctuation_delimiter">,</span>

	<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">isComplete</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Stage</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">self</span> <span class="operator">==</span> <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">confirmed</span> <span class="keyword_operator">or</span> <span class="constant variable_builtin type variable">self</span> <span class="operator">==</span> <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">err</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<blockquote><p>如果需要枚举的字符串表示，可以使用内置的 <code>@tagName(enum)</code> 函数。</p></blockquote><p>回想一下，结构类型可以使用 <code>.{...}</code> 符号根据其赋值或返回类型来推断。在上面，我们看到枚举类型是根据与 <code>self</code> 的比较推导出来的，而 <code>self</code> 的类型是 <code>Stage</code>。我们本可以明确地写成：<code>return self == Stage.confirmed</code> 或 <code>self == Stage.err</code>。但是，在处理枚举时，你经常会看到通过 <code>.$value</code> 这种省略具体类型的情况。这被称为<em>枚举字面量</em>。</p><p><code>switch</code> 的穷举性质使它能与枚举很好地搭配，因为它能确保你处理了所有可能的情况。不过在使用 <code>switch</code> 的 <code>else</code> 子句时要小心，因为它会匹配任何新添加的枚举值，而这可能不是我们想要的行为。</p><h1>带标签的联合 Tagged Union</h1><p>联合定义了一个值可以具有的一系列类型。例如，这个 <code>Number</code> 可以是整数、浮点数或 nan（非数字）：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">n</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">Number</span><span class="punctuation_bracket">{</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">int</span> <span class="operator">=</span> <span class="number">32</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">n</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">int</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword">const</span> <span class="constant variable_builtin type variable">Number</span> <span class="operator">=</span> <span class="keyword_type">union</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">int</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">float</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">nan</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">void</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>一个联合一次只能设置一个字段；试图访问一个未设置的字段是错误的。既然我们已经设置了 <code>int</code> 字段，如果我们试图访问 <code>n.float</code>，就会出错。我们的一个字段 <code>nan</code> 是 <code>void</code> 类型。我们该如何设置它的值呢？使用 <code>{}</code>：</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">n</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">Number</span><span class="punctuation_bracket">{</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">nan</span> <span class="operator">=</span> <span class="punctuation_bracket">{</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>使用联合的一个难题是要知道设置的是哪个字段。这就是带标签的联合发挥作用的地方。带标签的联合将枚举与联合定义在一起，可用于 <code>switch</code> 语句中。请看下面这个例子：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">ts</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">Timestamp</span><span class="punctuation_bracket">{</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">unix</span> <span class="operator">=</span> <span class="number">1693278411</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">ts</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">seconds</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword">const</span> <span class="constant variable_builtin type variable">TimestampType</span> <span class="operator">=</span> <span class="keyword_type">enum</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">unix</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">datetime</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

<span class="keyword">const</span> <span class="constant variable_builtin type variable">Timestamp</span> <span class="operator">=</span> <span class="keyword_type">union</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">TimestampType</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">unix</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">datetime</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">DateTime</span><span class="punctuation_delimiter">,</span>

	<span class="keyword">const</span> <span class="constant variable_builtin type variable">DateTime</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable_member variable">year</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u16</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">month</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">day</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">hour</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">minute</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
		<span class="constant variable_builtin type variable_member variable">second</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">seconds</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Timestamp</span><span class="punctuation_bracket">)</span> <span class="type_builtin">u16</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_conditional">switch</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">self</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
			<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">datetime</span> <span class="punctuation_delimiter">=&gt;</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">dt</span><span class="punctuation_bracket operator">|</span> <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">dt</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">second</span><span class="punctuation_delimiter">,</span>
			<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">unix</span> <span class="punctuation_delimiter">=&gt;</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">ts</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
				<span class="keyword">const</span> <span class="module constant variable_builtin type variable">seconds_since_midnight</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@rem</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ts</span><span class="punctuation_delimiter">,</span> <span class="number">86400</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
				<span class="keyword_return">return</span> <span class="function_builtin">@intCast</span><span class="punctuation_bracket">(</span><span class="function_builtin">@rem</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">seconds_since_midnight</span><span class="punctuation_delimiter">,</span> <span class="number">60</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
			<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_bracket">}</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>请注意， <code>switch</code> 中的每个分支捕获了字段的类型值。也就是说，<code>dt</code> 是 <code>Timestamp.DateTime</code> 类型，而 <code>ts</code> 是 <code>i32</code> 类型。这也是我们第一次看到嵌套在其他类型中的结构。<code>DateTime</code> 本可以在联合之外定义。我们还看到了两个新的内置函数：<code>@rem</code> 用于获取余数，<code>@intCast</code> 用于将结果转换为 <code>u16</code>（<code>@intCast</code> 从返回值类型中推断出我们需要 <code>u16</code>）。</p><p>从上面的示例中我们可以看出，带标签的联合的使用有点像接口，只要我们提前知道所有可能的实现，我们就能够将其转化带标签的联合这种形式。</p><p>最后，带标签的联合中的枚举类型可以自动推导出来。我们可以直接这样做：</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">Timestamp</span> <span class="operator">=</span> <span class="keyword_type">union</span><span class="punctuation_bracket">(</span><span class="keyword_type">enum</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">unix</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">datetime</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">DateTime</span><span class="punctuation_delimiter">,</span>

	<span class="variable_builtin">...</span>
</code></pre>
<p>这里 Zig 会根据带标签的联合，自动创建一个隐式枚举。</p><h1>可选类型 Optional</h1><p>在类型前加上问号 <code>?</code>，任何值都可以声明为可选类型。可选类型既可以是 <code>null</code>，也可以是已定义类型的值：</p><pre><code class="zig"><span class="keyword">var</span> <span class="constant variable_builtin type variable">home</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u8</span> <span class="operator">=</span> <span class="constant_builtin">null</span><span class="punctuation_delimiter">;</span>
<span class="keyword">var</span> <span class="constant variable_builtin type variable">name</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u8</span> <span class="operator">=</span> <span class="string">&quot;Leto&quot;</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>明确类型的必要性应该很清楚：如果我们只使用 const name = <code>&quot;Leto&quot;</code>，那么推导出的类型将是非可选的 <code>[]const u8</code>。</p><p><code>.?</code>用于访问可选类型后面的值：</p><pre><code class="zig"><span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{s}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">name</span><span class="operator">.?</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

</code></pre>
<p>但如果在 <code>null</code> 上使用 <code>.?</code>，运行时就会 <code>panic</code>。<code>if</code> 语句可以安全地取出可选类型背后的值：</p><pre><code class="zig"><span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">home</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">h</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// h is a []const u8</span>
	<span class="comment_documentation comment spell">// we have a home value</span>
<span class="punctuation_bracket">}</span> <span class="keyword_conditional">else</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// we don&apos;t have a home value</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p><code>orelse</code> 可用于提取可选类型的值或执行代码。这通常用于指定默认值或从函数中返回：</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">h</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">home</span> <span class="keyword_operator">orelse</span> <span class="string">&quot;unknown&quot;</span>

<span class="comment_documentation comment spell">// 或直接返回函数</span>
<span class="keyword">const</span> h <span class="operator">=</span> <span class="constant variable_builtin type variable">home</span> <span class="keyword_operator">orelse</span> <span class="keyword_return">return</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>不过，orelse 也可以带一个代码块，用于执行更复杂的逻辑。可选类型还可以与 <code>while</code> 整合，经常用于创建迭代器。我们这里忽略迭代器的细节，但希望这段伪代码能说明问题：</p><pre><code class="zig"><span class="keyword_repeat">while</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">rows</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">next</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">row</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// do something with our row</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h1>未定义的值 Undefined</h1><p>到目前为止，我们看到的每一个变量都被初始化为一个合理的值。但有时我们在声明变量时并不知道它的值。可选类型是一种选择，但并不总是合理的。在这种情况下，我们可以将变量设置为未定义，让其保持未初始化状态。</p><p>通常这样做的一个地方是创建数组，其值将由某个函数来填充：</p><pre><code class="zig"><span class="keyword">var</span> <span class="constant variable_builtin type variable">pseudo_uuid</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="number">16</span><span class="punctuation_bracket">]</span><span class="type_builtin">u8</span> <span class="operator">=</span> <span class="constant_builtin">undefined</span><span class="punctuation_delimiter">;</span>
<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">crypto</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">random</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">bytes</span><span class="punctuation_bracket">(</span><span class="operator">&amp;</span><span class="constant variable_builtin type variable">pseudo_uuid</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>上述代码仍然创建了一个 16 字节的数组，但它的每个元素都没有被赋值。</p><h1>错误 Errors</h1><p>Zig 中错误处理功能十分简单、实用。这一切都从错误集（error sets）开始，错误集的使用方式类似于枚举：</p><pre><code class="zig"><span class="comment_documentation comment spell">// 与第 1 部分中的结构一样，OpenError 也可以标记为 &quot;pub&quot;。</span>
<span class="comment_documentation comment spell">// 使其可以在其定义的文件之外访问</span>
<span class="keyword">const</span> <span class="constant variable_builtin type variable">OpenError</span> <span class="operator">=</span> <span class="keyword">error</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">AccessDenied</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">NotFound</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>任意函数（包括 <code>main</code>）都可以返回这个错误：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">OpenError</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">AccessDenied</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword">const</span> <span class="constant variable_builtin type variable">OpenError</span> <span class="operator">=</span> <span class="keyword">error</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">AccessDenied</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable">NotFound</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>如果你尝试运行这个程序，你会得到一个错误：<code>expected type &apos;void&apos;, found &apos;error{AccessDenied,NotFound}&apos;</code>。这是有道理的：我们定义了返回类型为 <code>void</code> 的 <code>main</code> 函数，但我们却返回了另一种东西（很明显，它是一个错误，而不是 <code>void</code>）。要解决这个问题，我们需要更改函数的返回类型。</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="constant variable_builtin type variable">OpenError</span><span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="constant variable_builtin type variable">OpenError</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">AccessDenied</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>这就是所谓的错误联合类型，它表示我们的函数既可以返回 <code>OpenError</code> 错误，也可以返回 <code>void</code>（也就是什么都没有）。到目前为止，我们已经非常明确：我们为函数可能返回的错误创建了一个错误集，并在函数的错误联合类型中使用了该错误集。但是，说到错误，Zig 有一些巧妙的技巧。首先，我们可以让 Zig 通过使用 <code>!return_type</code> 来推导错误集，而不是将 <code>error union</code> 指定为 <code>error_set!return_type</code>。因此，我们可以（也推荐）将我们 <code>main</code> 函数定义为：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span>

</code></pre>
<p>其次，Zig 能够为我们隐式创建错误集。我们可以这样做，而不需要提前声明：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_return">return</span> <span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">AccessDenied</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>完全显式和隐式方法并不完全等同。例如，引用具有隐式错误集的函数时，需要使用特殊的 <code>anyerror</code> 类型。类库开发人员可能会发现显式的好处，比如可以达到代码即文档的效果。不过，我认为隐式错误集和推导错误联合类型都很实用；我在平时编程中，大量使用了这两种方法。</p><p>错误联合类型的真正价值在于 Zig 语言提供了 <code>catch</code> 和 <code>try</code> 来处理它们。返回错误联合类型的函数调用时，可以包含一个 <code>catch</code> 子句。例如，一个 http 服务器库的代码可能如下所示：</p><pre><code class="zig"><span class="constant variable_builtin function_call variable type">action</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">req</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">res</span><span class="punctuation_bracket">)</span> <span class="keyword_exception">catch</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">err</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
	<span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">err</span> <span class="operator">==</span> <span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">BrokenPipe</span> <span class="keyword_operator">or</span> <span class="constant variable_builtin type variable">err</span> <span class="operator">==</span> <span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">ConnectionResetByPeer</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_return">return</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span> <span class="keyword_conditional">else</span> <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">err</span> <span class="operator">==</span> <span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">BodyTooBig</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">status</span> <span class="operator">=</span> <span class="number">431</span><span class="punctuation_delimiter">;</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">body</span> <span class="operator">=</span> <span class="string">&quot;Request body is too big&quot;</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span> <span class="keyword_conditional">else</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">status</span> <span class="operator">=</span> <span class="number">500</span><span class="punctuation_delimiter">;</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">body</span> <span class="operator">=</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation_delimiter">;</span>
		<span class="comment_documentation comment spell">// todo: log err</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p><code>switch</code> 的版本更符合惯用法：</p><pre><code class="zig"><span class="constant variable_builtin function_call variable type">action</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">req</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">res</span><span class="punctuation_bracket">)</span> <span class="keyword_exception">catch</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">err</span><span class="punctuation_bracket operator">|</span> <span class="keyword_conditional">switch</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">err</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">BrokenPipe</span><span class="punctuation_delimiter">,</span> <span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">ConnectionResetByPeer</span><span class="punctuation_bracket">)</span> <span class="punctuation_delimiter">=&gt;</span> <span class="keyword_return">return</span><span class="punctuation_delimiter">,</span>
	<span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">BodyTooBig</span> <span class="punctuation_delimiter">=&gt;</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">status</span> <span class="operator">=</span> <span class="number">431</span><span class="punctuation_delimiter">;</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">body</span> <span class="operator">=</span> <span class="string">&quot;Request body is too big&quot;</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">,</span>
	<span class="keyword_conditional">else</span> <span class="punctuation_delimiter">=&gt;</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">status</span> <span class="operator">=</span> <span class="number">500</span><span class="punctuation_delimiter">;</span>
		<span class="constant variable_builtin type variable">res</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">body</span> <span class="operator">=</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>这看起来花哨，但老实说，你在 <code>catch</code> 中最有可能做的事情就是把错误信息给调用者：</p><pre><code class="zig"><span class="constant variable_builtin function_call variable type">action</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">req</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">res</span><span class="punctuation_bracket">)</span> <span class="keyword_exception">catch</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">err</span><span class="punctuation_bracket operator">|</span> <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">err</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>这种模式非常常见，因此 Zig 提供了 <code>try</code> 关键字用于处理这种情况。上述代码的另一种写法如下：</p><pre><code class="zig"><span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">action</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">req</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">res</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>鉴于必须处理错误，这一点尤其有用。多数情况下的做法就是使用 <code>try</code> 或 <code>catch</code>。</p><blockquote><p>Go 开发人员会注意到，<code>try</code> 比 <code>if err != nil { return err }</code> 的按键次数更少。</p></blockquote><p>大多数情况下，你都会使用 <code>try</code> 和 <code>catch</code>，但 <code>if</code> 和 <code>while</code> 也支持错误联合类型，这与可选类型很相似。在 <code>while</code> 的情况下，如果条件返回错误，则执行 <code>else</code> 子句。</p><p>有一种特殊的 <code>anyerror</code> 类型可以容纳任何错误。虽然我们可以将函数定义为返回 <code>anyerror!TYPE</code> 而不是 <code>!TYPE</code>，但两者并不等同。<code>anyerror</code> 是全局错误集，是程序中所有错误集的超集。因此，在函数签名中使用 <code>anyerror</code> 很可能表示这个函数虽然可以返回错误，而实际上它大概率不会返回错误。 <code>anyerror</code> 主要用在可以是任意错误类型的函数参数或结构体字段中（想象一下日志库）。</p><p>函数同时返回可选类型与错误联合类型的情况并不少见。在推导错误集的情况下，形式如下：</p><pre><code class="zig"><span class="comment_documentation comment spell">// 载入上次保存的游戏</span>
<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">loadLast</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="operator">?</span><span class="constant variable_builtin type variable">Save</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// TODO</span>
	<span class="keyword_return">return</span> <span class="constant_builtin">null</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>使用此类函数有多种方法，但最简洁的方法是使用 <code>try</code> 来解除错误，然后使用 <code>orelse</code> 来解除可选类型。下面是一个大致的模式：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// This is the line you want to focus on</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">save</span> <span class="operator">=</span> <span class="punctuation_bracket">(</span><span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">Save</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">loadLast</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="keyword_operator">orelse</span> <span class="constant variable_builtin type variable">Save</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">blank</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">save</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">Save</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">lives</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">level</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u16</span><span class="punctuation_delimiter">,</span>

	<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">loadLast</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="operator">?</span><span class="constant variable_builtin type variable">Save</span> <span class="punctuation_bracket">{</span>
		<span class="comment_documentation comment spell">//todo</span>
		<span class="keyword_return">return</span> <span class="constant_builtin">null</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>

	<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">blank</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="constant variable_builtin type variable">Save</span> <span class="punctuation_bracket">{</span>
		<span class="keyword_return">return</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span>
			<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">lives</span> <span class="operator">=</span> <span class="number">3</span><span class="punctuation_delimiter">,</span>
			<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">level</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<hr><p>虽然我们还未涉及 Zig 语言中更高级的功能，但我们在前两部分中看到的是 Zig 语言重要组成部分。它们将作为一个基础，让我们能够探索更复杂的话题，而不用被语法所困扰。</p></div>

    <footer>
      <div>
        <div>
          <p>&copy; 2022–2025 |
            <a href="https://github.com/zigcc/zigcc.github.io">Source Code</a>
            |
            <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">BY-NC-ND 4.0</a>
            |
            <!--TODO <a href="/index.xml">RSS</a> --></p>
        </div>
        <div>
          <a href="https://github.com/orgs/zigcc/discussions">
            <i class="fab fa-github"></i>
          </a>
          <a href="https://discord.gg/UraRxD6WXD">
            <i class="fab fa-discord"></i>
          </a>
          <a href="https://t.me/ZigChinese">
            <i class="fab fa-telegram"></i>
          </a>
          <a href="mailto:hello@ziglang.cc">
            <i class="fa fa-envelope"></i>
          </a>
        </div>
      </div>
    </footer>
  </body>
</html>