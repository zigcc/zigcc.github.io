<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <meta name="description" content="Zig Chinese Community is dedicated to sharing and spreading the use of Zig language among Chinese users.">
    <title>Zig 语言中文社区</title>
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- TODO replace this -->
    
  <link type="text/css" rel="stylesheet" href="/style.css">

  </head>
  <body id="body">
    <div class="header">
      <a href="/" class="site-title"><h1>Zig 语言中文社区</h1></a>
      <nav>
        <a href="/learn/">学习 Zig</a>
         &nbsp; • &nbsp;
        <a href="/monthly/">月刊</a>
         &nbsp; • &nbsp;
        <a href="/post/">博客</a>
         &nbsp; • &nbsp;
        <a href="/contributing/">贡献</a>
         &nbsp; • &nbsp;
        <a href="/community/">社区</a>
      </nav>
    </div>
    
  <!-- TODO: 根据页面内容长度决定是否显示 TOC -->
  <div class="docs">
    <!-- TODO: 层级 h1 -->
    <h1>Table of Contents</h1>
    <div><ul>
<li>方法</li><li>常量函数参数</li><li>指向指针的指针</li><li>嵌套指针</li><li>递归结构</ul></div>
  </div>
  <div class="content"><blockquote><p>原文地址：<a href="https://www.openmymind.net/learning_zig/pointers" target="_blank">https://www.openmymind.net/learning_zig/pointers</a></p></blockquote><p>Zig 不包含垃圾回收器。管理内存的重任由开发者负责。这是一项重大责任，因为它直接影响到应用程序的性能、稳定性和安全性。</p><p>我们将从指针开始讨论，这本身就是一个重要的话题，同时也是训练我们从面向内存的角度来看待程序数据的开始。如果你已经对指针、堆分配和悬挂指针了如指掌，那么可以跳过本小节和下一小节，直接阅读[堆内存和分配器]({{< ref heap-memory-and-allocator.md >}})，这部分内容与 Zig 更为相关。</p><hr><p>下面的代码创建了一个 <code>power</code> 为 100 的用户，然后调用 <code>levelUp</code> 函数将用户的 <code>power</code> 加一。你能猜到它的输出结果吗？</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="comment_documentation comment spell">// this line has been added</span>
	<span class="constant variable_builtin function_call variable type">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;User {d} has power of {d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>这里我设置了一个陷阱，此段代码将无法编译：<em>局部变量从未被修改</em>。这是指 <code>main</code> 函数中的 <code>user</code> 变量。一个从未被修改的变量必须声明为 const。你可能会想：但在 <code>levelUp</code> 函数中我们确实修改了 <code>user</code>，这怎么回事？让我们假设 Zig 编译器弄错了，并试着糊弄它。我们将强制让编译器看到 <code>user</code> 确实被修改了：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>

	<span class="comment_documentation comment spell">// 代码的其余部分保持不变。</span>
</code></pre>
<p>现在我们在 <code>levelUp</code> 中遇到了一个错误：<strong>不能赋值给常量</strong>。我们在第一部分中看到函数参数是常量，因此 <code>user.power += 1</code> 是无效的。为了解决这个错误，我们可以将 <code>levelUp</code> 函数改为</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">u</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">u</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>虽然编译成功了，但输出结果却是<code>User 1 has power of 100</code>，而我们代码的目的显然是让 <code>levelUp</code> 将用户的 <code>power</code> 提升到 101。这是怎么回事？</p><p>要理解这一点，我们可以将数据与内存联系起来，而变量只是将类型与特定内存位置关联起来的标签。例如，在 <code>main</code> 中，我们创建了一个<code>User</code>。内存中数据的简单可视化表示如下</p><pre><code>user -&gt; ------------ (id)
        |    1     |
        ------------ (power)
        |   100    |
        ------------
</code></pre><p>有两点需要注意：</p><ol><li>我们的<code>user</code>变量指向结构的起点</li><li>字段是按顺序排列的</li></ol><p>请记住，我们的<code>user</code>也有一个类型。该类型告诉我们 <code>id</code> 是一个 64 位整数，<code>power</code> 是一个 32 位整数。有了对数据起始位置的引用和类型，编译器就可以将 <code>user.power</code> 转换为：访问位置在结构体第 64 位上的一个 32 位整数。这就是变量的威力，它们可以引用内存，并包含以有意义的方式理解和操作内存所需的类型信息。</p><blockquote><p>默认情况下，Zig 不保证结构的内存布局。它可以按字母顺序、大小升序或插入填充（padding）某些字段。只要它能正确翻译我们的代码，它就可以为所欲为。这种自由度可以实现某些优化。只有在声明 <code>packed struct</code>时，我们才能获得内存布局的有力保证。我们还可以创建一个 <code>extern struct</code>，这样可以保证内存布局与 C 应用程序二进制接口 (ABI) 匹配。尽管如此，我们对<code>user</code>的可视化还是合理而有用的。</p></blockquote><p>下面是一个稍有不同的可视化效果，其中包括内存地址。这些数据的起始内存地址是我想出来的一个随机地址。这是<code>user</code>变量引用的内存地址，也是第一个字段 <code>id</code> 的值所在的位置。由于 <code>id</code> 是一个 64 位整数，需要 8 字节内存。因此，<code>power</code> 必须位于 <code>$start_address + 8</code> 上：</p><pre><code>user -&gt;   ------------  (id: 1043368d0)
          |    1     |
          ------------  (power: 1043368d8)
          |   100    |
          ------------
</code></pre><p>为了验证这一点，我想介绍一下取地址符运算符：<code>&amp;</code>。顾名思义，取地址运算符返回一个变量的地址（它也可以返回一个函数的地址，是不是很神奇？）保留现有的 <code>User</code> 定义，试试下面的代码：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{*}</span><span class="string string_escape">\n</span><span class="string">{*}</span><span class="string string_escape">\n</span><span class="string">{*}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>这段代码输出了<code>user</code>、<code>user.id</code>、和<code>user.power</code>的地址。根据平台等差异，可能会得到不同的输出结果，但都会看到<code>user</code>和<code>user.id</code>的地址相同，而<code>user.power</code>的地址偏移量了 8 个字节。输出的结果如下：</p><pre><code>learning.User@1043368d0
u64@1043368d0
i32@1043368d8
</code></pre><p>取地址运算符返回一个指向值的指针。指向值的指针是一种特殊的类型。类型<code>T</code>的值的地址是<code>*T</code>。因此，如果我们获取 <code>user</code> 的地址，就会得到一个 <code>*User</code>，即一个指向 <code>User</code> 的指针：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>

	<span class="keyword">const</span> <span class="constant variable_builtin type variable">user_p</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="function_builtin">@TypeOf</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">user_p</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>我们最初的目标是通过<code>levelUp</code>函数将用户的<code>power</code>值增加 1 。我们已经让代码编译通过，但当我们打印<code>power</code>时，它仍然是原始值。虽然有点跳跃，但让我们修改代码，在 <code>main</code> 和 <code>levelUp</code> 中打印 <code>user</code>的地址：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">0</span><span class="punctuation_delimiter">;</span>

	<span class="comment_documentation comment spell">// added this</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;main: {*}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

	<span class="constant variable_builtin function_call variable type">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;User {d} has power of {d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="comment_documentation comment spell">// add this</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;levelUp: {*}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">u</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">u</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>如果运行这个程序，会得到两个不同的地址。这意味着在 <code>levelUp</code> 中被修改的 <code>user</code>与 <code>main</code> 中的<code>user</code>是不同的。这是因为 Zig 传递了一个值的副本。这似乎是一个奇怪的默认行为，但它的好处之一是，函数的调用者可以确保函数不会修改参数（因为它不能）。在很多情况下，有这样的保证是件好事。当然，有时我们希望函数能修改参数，比如 <code>levelUp</code>。为此，我们需要 <code>levelUp</code> 作用于 <code>main</code> 中 <code>user</code>，而不是其副本。我们可以通过向函数传递 <code>user</code>的地址来实现这一点：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="comment_documentation comment spell">// no longer needed</span>
	<span class="comment_documentation comment spell">// user.power += 1;</span>

	<span class="comment_documentation comment spell">// user -&gt; &amp;user</span>
	<span class="constant variable_builtin function_call variable type">levelUp</span><span class="punctuation_bracket">(</span><span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;User {d} has power of {d}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="comment_documentation comment spell">// User -&gt; *User</span>
<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>我们必须做两处改动。首先是用 <code>user</code> 的地址（即 <code>&amp;user</code> ）来调用 <code>levelUp</code>，而不是 <code>user</code>。这意味着我们的函数参数不再是 <code>User</code>，取而代之的是一个 <code>*User</code>，这是我们的第二处改动。</p><p>我们不再需要通过 <code>user.power += 0;</code> 来强制修改 user 的那个丑陋的技巧了。最初，我们因为 user 是 var 类型而无法让代码编译，编译器告诉我们它从未被修改。我们以为编译器错了，于是通过强制修改来“糊弄”它。但正如我们现在所知道的，在 levelUp 中被修改的 user 是不同的；编译器是正确的。</p><p>现在，代码已按预期运行。虽然在函数参数和内存模型方面仍有许多微妙之处，但我们正在取得进展。现在也许是一个好时机来说明一下，除了特定的语法之外，这些都不是 Zig 所独有的。我们在这里探索的模型是最常见的，有些语言可能只是向开发者隐藏了很多细节，因此也就隐藏了灵活性。</p><h1>方法</h1><p>一般来说，我们会把 <code>levelUp</code> 写成 <code>User</code>结构的一个方法：</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>

	<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
		<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
	<span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>这就引出了一个问题：我们如何调用带有指针参数的方法？也许我们必须这样做：<code>&amp;user.levelUp()</code>？实际上，只需正常调用即可，即 user.levelUp()。Zig 知道该方法需要一个指针，因此会正确地传递值（通过引用传递）。</p><p>我最初选择函数是因为它很明确，因此更容易学习。</p><h1>常量函数参数</h1><p>我不止一次暗示过，在默认情况下，Zig 会传递一个值的副本（称为 “按值传递”）。很快我们就会发现，实际情况要更微妙一些（提示：嵌套对象的复杂值怎么办？）</p><p>即使坚持使用简单类型，事实也是 Zig 可以随心所欲地传递参数，只要它能保证代码的意图不受影响。在我们最初的 <code>levelUp</code> 中，参数是一个<code>User</code>，Zig 可以传递用户的副本或对 <code>main.user</code> 的引用，只要它能保证函数不会对其进行更改即可。(我知道我们最终确实希望它被改变，但通过采用 <code>User</code> 类型，我们告诉编译器我们不希望它被改变）。</p><p>这种自由度允许 Zig 根据参数类型使用最优策略。像 User 这样的小类型可以通过值传递（即复制），成本较低。较大的类型通过引用传递可能更便宜。只要代码的意图得以保留，Zig 可以使用任何方法。在某种程度上，使用常量函数参数可以做到这一点。</p><p>现在你知道函数参数是常量的原因之一了吧。</p><blockquote><p>也许你会想，即使与复制一个非常小的结构相比，通过引用传递怎么会更慢呢？我们接下来会更清楚地看到这一点，但要点是，当 <code>user</code> 是指针时，执行 <code>user.power</code> 会增加一点点开销。编译器必须权衡复制的代价和通过指针间接访问字段的代价。</p></blockquote><h1>指向指针的指针</h1><p>我们之前查看了<code>main</code>函数中 <code>user</code> 的内存结构。现在我们改变了 <code>levelUp</code>，那么它的内存会是什么样的呢？</p><pre><code>main:
user -&gt; ------------  (id: 1043368d0)  &lt;---
        |    1     |                      |
        ------------  (power: 1043368d8)  |
        |   100    |                      |
        ------------                      |
                                          |
        .............  empty space        |
        .............  or other data      |
                                          |
levelUp:                                  |
user -&gt; -------------  (*User)            |
        | 1043368d0 |----------------------
        -------------
</code></pre><p>在 <code>levelUp</code> 中，<code>user</code> 是指向 <code>User</code> 的指针。它的值是一个地址。当然不是任何地址，而是 <code>main.user</code> 的地址。值得明确的是，<code>levelUp</code> 中的 <code>user</code> 变量代表一个具体的值。这个值恰好是一个地址。而且，它不仅仅是一个地址，还是一个类型，即 <code>*User</code>。这一切都非常一致，不管我们讨论的是不是指针：变量将类型信息与地址联系在一起。指针的唯一特殊之处在于，当我们使用点语法时，例如 <code>user.power</code>，Zig 知道 <code>user</code> 是一个指针，就会自动跟随地址。</p><blockquote><p>通过指针访问字段时，有些语言可能会使用不同的运算符。</p></blockquote><p>重要的是要理解，<code>levelUp</code>函数中的<code>user</code>变量本身存在于内存中的某个地址。就像之前所做的一样，我们可以亲自验证这一点：</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{*}</span><span class="string string_escape">\n</span><span class="string">{*}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="operator">&amp;</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>上面打印了<code>user</code>变量引用的地址及其值，这个值就是<code>main</code>函数中的<code>user</code>的地址。</p><p>如果<code>user</code>的类型是<code>*User</code>，那么<code>&amp;user</code>呢？它的类型是<code>**User</code>, 或者说是一个指向<code>User</code>指针的指针。我可以一直这样做，直到内存溢出！</p><p>我们可以使用多级间接指针，但这并不是我们现在所需要的。本节的目的是说明指针并不特殊，它只是一个值，即一个地址和一种类型。</p><h1>嵌套指针</h1><p>到目前为止，<code>User</code> 一直很简单，只包含两个整数。很容易就能想象出它的内存，而且当我们谈论『复制』 时，也不会有任何歧义。但是，如果 User 变得更加复杂并包含一个指针，会发生什么情况呢？</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">name</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>我们已经添加了<code>name</code>，它是一个切片。回想一下，切片由长度和指针组成。如果我们使用名字<code>Goku</code>初始化<code>user</code>，它在内存中会是什么样子？</p><pre><code>user -&gt; -------------  (id: 1043368d0)
        |     1     |
        -------------  (power: 1043368d8)
        |    100    |
        -------------  (name.len: 1043368dc)
        |     4     |
        -------------  (name.ptr: 1043368e4)
  ------| 1182145c0 |
  |     -------------
  |
  |     .............  empty space
  |     .............  or other data
  |
  ---&gt;  -------------  (1182145c0)
        |    &apos;G&apos;    |
        -------------
        |    &apos;o&apos;    |
        -------------
        |    &apos;k&apos;    |
        -------------
        |    &apos;u&apos;    |
        -------------
</code></pre><p>新的<code>name</code>字段是一个切片，由<code>len</code>和<code>ptr</code>字段组成。它们与所有其他字段一起按顺序排放。在 64 位平台上，<code>len</code>和<code>ptr</code>都将是 64 位，即 8 字节。有趣的是<code>name.ptr</code>的值：它是指向内存中其他位置的地址。</p><blockquote><p>由于我们使用了字符串字面形式，<code>user.name.ptr</code> 将指向二进制文件中存储所有常量的区域内的一个特定位置。</p></blockquote><p>通过多层嵌套，类型可以变得比这复杂得多。但无论简单还是复杂，它们的行为都是一样的。具体来说，如果我们回到原来的代码，<code>levelUp</code> 接收一个普通的 <code>User</code>，Zig 提供一个副本，那么现在有了嵌套指针后，情况会怎样呢？</p><p>答案是只会进行浅拷贝。或者像有些人说的那样，只拷贝了变量可立即寻址的内存。这样看来，<code>levelUp</code> 可能只会得到一个 <code>user</code> 残缺副本，<code>name</code> 字段可能是无效的。但请记住，像 <code>user.name.ptr</code> 这样的指针是一个值，而这个值是一个地址。它的副本仍然是相同的地址：</p><pre><code>main: user -&gt;    -------------  (id: 1043368d0)
                 |     1     |
                 -------------  (power: 1043368d8)
                 |    100    |
                 -------------  (name.len: 1043368dc)
                 |     4     |
                 -------------  (name.ptr: 1043368e4)
                 | 1182145c0 |-------------------------
levelUp: user -&gt; -------------  (id: 1043368ec)       |
                 |     1     |                        |
                 -------------  (power: 1043368f4)    |
                 |    100    |                        |
                 -------------  (name.len: 1043368f8) |
                 |     4     |                        |
                 -------------  (name.ptr: 104336900) |
                 | 1182145c0 |-------------------------
                 -------------                        |
                                                      |
                 .............  empty space           |
                 .............  or other data         |
                                                      |
                 -------------  (1182145c0)        &lt;---
                 |    &apos;G&apos;    |
                 -------------
                 |    &apos;o&apos;    |
                 -------------
                 |    &apos;k&apos;    |
                 -------------
                 |    &apos;u&apos;    |
                 -------------
</code></pre><p>从上面可以看出，浅拷贝是可行的。由于指针的值是一个地址，复制该值意味着我们得到的是相同的地址。这对可变性有重要影响。我们的函数不能更改 <code>main.user</code> 中的字段，因为它得到了一个副本，但它可以访问同一个<code>name</code>，那么它能更改 <code>name</code> 吗？在这种特殊情况下，不行，因为 <code>name</code> 是常量。另外，<code>Goku</code>是一个字符串字面量，它总是不可变的。不过，只要花点功夫，我们就能明白浅拷贝的含义：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">var</span> <span class="constant variable_builtin type variable">name</span> <span class="operator">=</span> <span class="punctuation_bracket">[</span><span class="number">4</span><span class="punctuation_bracket">]</span><span class="type_builtin">u8</span><span class="punctuation_bracket">{</span><span class="character">&apos;G&apos;</span><span class="punctuation_delimiter">,</span> <span class="character">&apos;o&apos;</span><span class="punctuation_delimiter">,</span> <span class="character">&apos;k&apos;</span><span class="punctuation_delimiter">,</span> <span class="character">&apos;u&apos;</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">user</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation_delimiter">,</span>
		<span class="comment_documentation comment spell">// slice it, [4]u8 -&gt; []u8</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">name</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">name</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="operator">..</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin function_call variable type">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{s}</span><span class="string string_escape">\n</span><span class="string">&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">name</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">levelUp</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">user</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable">user</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">name</span><span class="punctuation_bracket">[</span><span class="number">2</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="character">&apos;!&apos;</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
	<span class="comment_documentation comment spell">// []const u8 -&gt; []u8</span>
	<span class="constant variable_builtin type variable_member variable">name</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="type_builtin">u8</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>上面的代码会打印出<code>Go!u</code>。我们不得不将<code>name</code>的类型从<code>[]const u8</code>更改为<code>[]u8</code>，并且不再使用字符串字面量（它们总是不可变的），而是创建一个数组并对其进行切片。有些人可能会认为这前后不一致。通过值传递可以防止函数改变直接字段，但不能改变指针后面有值的字段。如果我们确实希望 <code>name</code> 不可变，就应该将其声明为 <code>[]const u8</code> 而不是 <code>[]u8</code>。</p><p>不同编程语言有不同的实现方式，但许多语言的工作方式与此完全相同（或非常接近）。虽然所有这些看似深奥，但却是日常编程的基础。好消息是，你可以通过简单的示例和片段来掌握这一点；它不会随着系统其他部分复杂性的增加而变得更加复杂。</p><h1>递归结构</h1><p>有时你需要一个递归结构。在保留现有代码的基础上，我们为 <code>User</code> 添加一个可选的 <code>manager</code> 字段，类型为 <code>?User</code>。同时，我们将创建两个<code>User</code>，并将其中一个指定为另一个的管理者：</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">leto</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">9001</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">manager</span> <span class="operator">=</span> <span class="constant_builtin">null</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="keyword">const</span> <span class="constant variable_builtin type variable">duncan</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">9001</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">manager</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">leto</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">{any}&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">leto</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">duncan</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">manager</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="constant variable_builtin type variable">User</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>这段代码无法编译：<code>struct &apos;learning.User&apos; depends on itself</code>。这个问题的根本原因是每种类型都必须在编译时确定大小，而这里的递归结构体大小是无法确定的。</p><p>我们在添加 <code>name</code> 时没有遇到这个问题，尽管 <code>name</code>可以有不同的长度。问题不在于值的大小，而在于类型本身的大小。name 是一个切片，即 <code>[]const u8</code>，它有一个已知的大小：16 字节，其中 <code>len</code> 8 字节，<code>ptr</code> 8 字节。</p><p>你可能会认为这对任何 <code>Optional</code>或 <code>union</code> 来说都是个问题。但对于它们来说，最大字段的大小是已知的，这样 Zig 就可以使用它。递归结构没有这样的上限，该结构可以递归一次、两次或数百万次。这个次数会因<code>User</code>而异，在编译时是不知道的。</p><p>我们通过 <code>name</code> 看到了答案：使用指针。指针总是占用 <code>usize</code> 字节。在 64 位平台上，指针占用 8 个字节。就像<code>Goku</code>并没有与 <code>user</code>一起存储一样，使用指针意味着我们的<code>manager</code>不再与<code>user</code>的内存布局绑定。</p><pre><code class="zig"><span class="keyword">const</span> <span class="module constant variable_builtin type variable">std</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@import</span><span class="punctuation_bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">main</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">void</span> <span class="punctuation_bracket">{</span>
	<span class="keyword">const</span> <span class="constant variable_builtin type variable">leto</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">9001</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">manager</span> <span class="operator">=</span> <span class="constant_builtin">null</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="keyword">const</span> <span class="constant variable_builtin type variable">duncan</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_bracket">{</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation_delimiter">,</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">power</span> <span class="operator">=</span> <span class="number">9001</span><span class="punctuation_delimiter">,</span>
		<span class="comment_documentation comment spell">// changed from leto -&gt; &amp;leto</span>
		<span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">manager</span> <span class="operator">=</span> <span class="operator">&amp;</span><span class="constant variable_builtin type variable">leto</span><span class="punctuation_delimiter">,</span>
	<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

	<span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">debug</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">print</span><span class="punctuation_bracket">(</span><span class="string">&quot;{any}</span><span class="string string_escape">\n</span><span class="string">{any}&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">leto</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">duncan</span><span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_modifier">pub</span> <span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
	<span class="constant variable_builtin type variable_member variable">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>
	<span class="constant variable_builtin type variable_member variable">power</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span>
	<span class="comment_documentation comment spell">// changed from ?const User -&gt; ?*const User</span>
	<span class="constant variable_builtin type variable_member variable">manager</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">User</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>你可能永远不需要递归结构，但这里并不是介绍数据建模的教程，因此不过多进行介绍。这里主要是想讨论指针和内存模型，以及更好地理解编译器的意图。</p><hr><p>很多开发人员都在为指针而苦恼，因为指针总是难以捉摸。它们给人的感觉不像整数、字符串或<code>User</code>那样具体。虽然你现在不必完全理解这些概念，但掌握它们是值得的，而且不仅仅是为了 Zig。这些细节可能隐藏在 Ruby、Python 和 JavaScript 等语言中，其次是 C#、Java 和 Go。它影响着你如何编写代码以及代码如何运行。因此，请慢慢来，多看示例，添加调试打印语句来查看变量及其地址。你探索得越多，就会越清楚。</p></div>

    <footer>
      <div>
        <div>
          <p>&copy; 2022–2025 |
            <a href="https://github.com/zigcc/zigcc.github.io">Source Code</a>
            |
            <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">BY-NC-ND 4.0</a>
            |
            <!--TODO <a href="/index.xml">RSS</a> --></p>
        </div>
        <div>
          <a href="https://github.com/orgs/zigcc/discussions">
            <i class="fab fa-github"></i>
          </a>
          <a href="https://discord.gg/UraRxD6WXD">
            <i class="fab fa-discord"></i>
          </a>
          <a href="https://t.me/ZigChinese">
            <i class="fab fa-telegram"></i>
          </a>
          <a href="mailto:hello@ziglang.cc">
            <i class="fa fa-envelope"></i>
          </a>
        </div>
      </div>
    </footer>
  </body>
</html>